!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.dizy=t():e.dizy=t()}(self,(()=>(()=>{var e={892:(e,t,n)=>{const s=n(452),r=n(904),i=n(946),a=n(398),o=n(882);e.exports.un=s,e.exports._V=i,e.exports.gg=a,e.exports.Mb=o,e.exports.qT=r},452:(e,t,n)=>{const s=n(957),r=n(882);class i extends Error{constructor(e){super(`Argument 'arg' of getArgumentDefaultValue(arg) has invalid type - ${e}. Argument type must be a string.`)}}class a extends Error{constructor(){super("Argument 'arg' is an empty string.")}}e.exports=function(e){const t=r(e);if("string"!==t)throw new i(t);if(""===e)throw new a;const n=e.split("=");return{name:n[0].trim(),value:n.length>1?s(n[1].trim()):void 0}}},904:(e,t,n)=>{const s=n(882);class r extends Error{constructor(e){super(`Argument 'cls' of getBaseClass(cls) has invalid type - ${e}. Argument type must be a class or a function.`)}}e.exports=e=>{const t=s(e);if("class"!==t&&"function"!==t)throw new r(t);return"class"===t?e.prototype.__proto__.constructor:e.prototype}},946:(e,t,n)=>{const{findCloseBraceIndex:s,splitArgsStrByCommas:r}=n(398),i=n(882);class a extends Error{constructor(){super("DI object has no one constructor. Need one or more.")}}class o extends Error{constructor(e){super(`Argument cls with invalid type - ${e}. Argument value type must be a class.`)}}e.exports=e=>{const t=i(e);if("class"!==t)throw new o(t);const n=e.toString(),c=n.indexOf("constructor",0);if(-1===c)throw new a;const l=n.indexOf("(",c);let d=s(n,l);const u=n.slice(l+1,d);return{startPosition:c,args:r(u).map((e=>e.trim())).filter((e=>""!==e))}}},398:(e,t,n)=>{const s=n(882);class r extends Error{constructor(e){super(`Argument func with invalid type - ${e}. Argument value type must be a function.`)}}const i=(e,t)=>{const n=e.indexOf("(",t);let s=e.indexOf(")",n);const r=t=>e.split("").slice(n,t).map(((e,t)=>({char:e,index:t}))).filter((e=>"("===e.char)).length;let i=r(s),a=0;for(;i>1;)a++,s=e.indexOf(")",s+1),i=r(s)-a;return s},a=e=>{const t=e.split("").map(((e,t)=>({char:e,index:t}))).filter((e=>","===e.char));let n=0;return t.filter((t=>{const s=e.slice(n,t.index).split("").filter((e=>"("===e)).length,r=e.slice(n,t.index).split("").filter((e=>")"===e)).length,i=e.slice(n,t.index).split("").filter((e=>"{"===e)).length,a=e.slice(n,t.index).split("").filter((e=>"}"===e)).length;return s===r&&i===a&&(n=t.index,!0)})).map((e=>e.index))},o=e=>{const t=[-1,...a(e),null];return t.slice(1).map(((n,s)=>null===n?e.slice(t[s]+1):e.slice(t[s]+1,n)))};e.exports=e=>{const t=s(e);if("function"!==t&&"function class"!==t)throw new r(t);const n=e.toString(),a=n.indexOf("(",0),c=i(n,a),l=n.indexOf("=");let d;d=-1!==l&&(-1===a||l<a)?n.slice(0,l):a+1===c?"":n.slice(a+1,c);return{startPosition:-1===a?0:a,args:o(d).map((e=>e.trim())).filter((e=>""!==e))}},e.exports.findCloseBraceIndex=i,e.exports.splitArgsStrByCommas=o},957:(e,t,n)=>{const s=n(882);class r extends Error{constructor(e,t){super(`getStringifiedEntityName argument type is invalid (${e} - ${t}). 'entityStr' must be a string.`)}}class i extends Error{constructor(){super("getStringifiedEntityName argument is an empty string.")}}e.exports=e=>{const t=s(e);if("string"!==t)throw new r(e,t);if(""===e)throw new i;if(e.includes("WEBPACK_IMPORTED_MODULE")){const t=e.indexOf("_")+1,n=e.indexOf("_",t+1);return e.slice(t,n)}return e}},882:e=>{e.exports=function(e){const t=typeof e;if("function"!==t)return"object"===t&&null===e?"null":t;const n=e.toString();return n.startsWith("class")?"class":n.includes("_classCallCheck")?"function class":"function"}}},t={};function n(s){var r=t[s];if(void 0!==r)return r.exports;var i=t[s]={exports:{}};return e[s](i,i.exports,n),i.exports}n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var s={};return(()=>{"use strict";n.r(s);var e=n(892);class t extends Error{constructor(){this.message="Not implemented error",super(this.message)}}const r=class{constructor(e){this.id=e}beforeCreate(){throw new t}afterCreate(){throw new t}};const i=class{constructor(t,n,s,i,a,o){if("undefined"===(0,e.Mb)(t)||"null"===(0,e.Mb)(t)||"boolean"===(0,e.Mb)(t))throw new Error("DIClazz constructor argument 'key' is invalid. Argument 'key' must not be an undefined, null or boolean.");if("string"!==(0,e.Mb)(n))throw new Error("DIClazz constructor argument 'name' is invalid. Argument 'name' type must be a string.");if("class"!==(0,e.Mb)(s)&&"function"!==(0,e.Mb)(s)&&"function class"!==(0,e.Mb)(s))throw new Error("DIClazz constructor argument 'type' is invalid. Argument 'type' must be a class or a function.");if("boolean"!==(0,e.Mb)(i))throw new Error("DIClazz constructor argument 'isClass' is invalid. Argument 'isClass' must be a boolean.");if(!(a instanceof r))throw new Error("DIClazz constructor argument 'lifecycle' is invalid. Argument 'lifecycle' must be an instance of Lifecycle.");this.key=t,this.name=n,this.type=s,this.isClass=i,this.lifecycle=a,this.constructor=o}},a={Persistent:0,Session:1,Singletone:2,Demanded:3};const o=class extends r{constructor(e=(()=>{}),t=(()=>{})){super(a.Demanded),this.beforeCreate=e,this.afterCreate=t}};const c=class extends r{constructor(e=(()=>{}),t=(()=>{})){super(a.Session),this.beforeCreate=e,this.afterCreate=t}};const l=class extends r{constructor(e=(()=>{}),t=(()=>{})){super(a.Singletone),this.beforeCreate=e,this.afterCreate=t}};class d extends Error{constructor(e){super(`DI object name { ${e} } is invalid. Name must be a not empty string`),this.name="InvalidDIObjectName"}}Error;class u extends Error{constructor(e){super(`There is no registered lifecycle with id = ${e.id}.`),this.name="UnregisteredDIObjectLifecycle"}}class f extends Error{constructor(e){super(`Invalid lifecycle { ${e} }. lifecycle prop must be an instance of Lifecycle or it's derived class.`),this.name="InvalidDIObjectLifecycle"}}class h extends Error{constructor(e){super(`DI object type { ${e} } is invalid. type prop must be a class or a function`),this.name="InvalidDIObjectType"}}class y{constructor(t,n,s){if("string"!=typeof t&&"symbol"!=typeof t||!0==!t)throw new d(t);if("class"!==(0,e.Mb)(n)&&"function"!==(0,e.Mb)(n)&&"function class"!==(0,e.Mb)(n))throw new h(n);if(!(s instanceof r))throw new f(s);this.name=t,this.type=n,this.lifecycle=s}}class p extends Error{constructor(t){super(`DIObjectKey constructor argument ('key' = ${t?t.toString():t} (type - ${(0,e.Mb)(t)})) is invalid.\nArgument 'key' must be a string like '@{parentName}/{DIObjectName}/{lifecycleId}/{isClass}'`)}}const m=class{constructor(e){if("string"!=typeof e)throw new p(e);if(!/@[\w\s]+\/[\w\s]+\/[\d]+\/true/.test(e)&&!/@[\w\s]+\/[\w\s]+\/[\d]+\/false/.test(e))throw new p(e);this.key=e}parseKey(){const e=this.key.split("/");return{parent:{name:e[0].length>1?e[0].slice(1):""},name:e[1],lifecycle:Number(e[2]),isClass:Boolean(e[3])}}};class g extends Error{constructor(e,t){super(`${e} requires ${t}. And ${t} requires ${e}.`),this.name="Dependency loop error."}}const b=g;class w extends Error{constructor(){super("Invalid context config. Config must be an array of DIObjectConfig instances")}}const C=w;class x extends Error{constructor(e,t,n){super(`Invalid argument { ${t} } default value in ${e}. There is no { ${n} } in DI Container.`),this.name="Invalid DI Object arg default value error."}}const I=x;class D extends Error{constructor(e,t){super(`Invalid argument name { ${t} } in ${e}. There is no object with name { ${t} } in DI Container.`),this.name="Invalid DI Object arg name error."}}const v=D;class E extends Error{constructor(e){super(`Not allowed DI object type of ${e.__proto__.prototype.name}. DI object must be class or function.`),this.name="Invalid DI Object type."}}const N=E;const S=class{constructor(){}hasInstance(){}getInstance(){}filterInstances(){}getParent(){}typeMatch(e,t){}};class z extends i{constructor(t,n,s){if(!(t instanceof i))throw new Error("DependencyTreeNode 'baseClazz' is invalid. Constructor argument 'baseClazz' must be a DIClazz instance.");if("number"!==(0,e.Mb)(n))throw new Error(`DependencyTreeNode 'height' is invalid (type - ${(0,e.Mb)(n)}). Constructor argument 'height' must be a number`);if(!Array.isArray(s)||s.length&&s.find((e=>!(e instanceof z))))throw new Error("DependencyTreeNode 'deps' is invalid. Constructor argument 'deps' must be an array of DependencyTreeNode instances.");const{key:r,name:a,type:o,isClass:c,lifecycle:l,constructor:d}=t;super(r,a,o,c,l,d),this.height=n,this.deps=s}}const T=z;class k extends Error{constructor(){super("DependencyTree baseNode arg is invalid. Constructor argument 'baseNode' must be an instance of DependencyTreeNode")}}const j=class{constructor(e){if(!(e instanceof T))throw new k;this.baseNode=e}#e(e,t=this.baseNode){const n=[];return t.height<e?t.deps.forEach((t=>{n.push(...this.#e(e,t))})):t.height===e&&n.push(t),n}getDepsByHeight(t){if("number"!==(0,e.Mb)(t))throw new Error("getDepsByHeight arg 'height' is undefined. Argument 'height' value must be a positive number");if(t<0)throw new Error("getDepsByHeight arg 'height' is a negative number. Argument 'height' value must be a positive number");return this.#e(t)}groupByHeight(){let e=0;const t=[];let n=this.getDepsByHeight(e);for(;n&&n.length>0;)t.push({height:e,deps:n}),e++,n=this.getDepsByHeight(e);return t}};class A extends Error{constructor(){super("Invalid di parent. Parent must be an instance of AbstractDIContainer or it's derived class, null or undefined.")}}class O extends Error{constructor(){super("DIContainer constructor's argument 'classTreeList' is invalid. Argument 'classTreeList' must be an array of DependencyTree instances")}}class L extends S{constructor(e,t=[]){if(null!=e&&!(e instanceof L))throw new A;if(!Array.isArray(t)||t.length&&t.find((e=>!(e instanceof j))))throw new O;super(),this.classTreeList=t}}const _=L;class $ extends Error{constructor({parent:e,name:t,lifecycle:n,isClass:s}){super(`DI key with description {\n            parent: ${e?e.name:"null"},\n            name: ${t},\n            lifecycle: ${n.id},\n            isClass: ${s}\n        } isn't unique. There is another DI object with this key.`),this.name="NotUniqueDIKey"}}const M=class{constructor(e=new Map){this.#t=e}#t;createKey(e,t,n,s){this.#n(e,t,n,s);const r={parent:e,name:t,lifecycle:n,isClass:s},i=this.#s(r);if(this.#t.has(i))throw new $(r);const a=new m(i);return this.#t.set(i,a),a}#s({parent:e,name:t,lifecycle:n,isClass:s}){return console.log(e),`@${e?.name}/${t}/${n.id}/${s}`}#n(t,n,s,i){if(!(t instanceof V))throw new Error("DIObjectKeyFactory.create() 'parent' arg is invalid. 'parent' must be an instance of AbstractContextContainer");if("string"!==(0,e.Mb)(n))throw new Error("DIObjectKeyFactory.create() 'name' arg is invalid. 'name' must be a string.");if(""===n)throw new Error("DIObjectKeyFactory.create() 'name' arg is empty.");if(!(s instanceof r))throw new Error("DIObjectKeyFactory.create() 'lifecycle' arg is invalid. 'lifecycle' must be an instance of Lifecycle");if(!Object.values(a).find((e=>e===s.id)))throw new u(s);if("boolean"!==(0,e.Mb)(i))throw new Error("DIObjectKeyFactory.create() 'isClass' arg type is invalid. 'isClass' type must be boolean");return!0}};class F extends Error{constructor(){super("Argument 'baseClazz' is invalid. 'baseClazz' must be an instance of DIClazz"),this.name="DependencyTreeFactory.createDependencyTree() Error"}}class P extends Error{constructor(){super("Argument 'allClasses' is invalid. 'allClasses' must be a not empty array of DIClazz instances"),this.name="DependencyTreeFactory.createDependencyTree() Error"}}class K{static createDependencyTree(e,t){if(!(e instanceof i))throw new F;if(!Array.isArray(t)||t.length&&-1!==t.findIndex((e=>!(e instanceof i)))||!t.length)throw new P;const n=new T(e,0,[]);return K.#r(n,t),new j(n)}static#i(e,t){e.deps.push(t)}static#r(e,t){if(!(e.constructor.args.length>0))return e;e.constructor.args.forEach((n=>{const s=t.find((e=>e.name===n)),r=new T(s,e.height+1,[]);K.#i(e,r),K.#r(r,t)}))}}const B=K;class H extends Error{constructor(e,t){super(`The number of constructor arguments in the derived class ${e} must be >= than the number of\n            constructor arguments of its base class ${t}.`),this.name="Derived class constructor args count error"}}class R extends Error{constructor(){super("Invalid context child. Child must be an instance of AbstractContextContainer or it's derived class, null or undefined.")}}class q extends _{constructor(e=[],t="",n=null,s=new M){super(n,[]),this.config=e,this.name=t,this.#a=s}#o=!1;#c;#a;#l=[];#d=new Map;classTreeList=[];scopes=new Map;init(){this.#o||(this.classTreeList=[],this.#u(),this.#f(),this.#h(),this.#y(),this.classTreeList.sort(((e,t)=>e.baseNode.constructor.args.length-t.baseNode.constructor.args.length)),this._createScopes(),this._initScopes(),this.#d.forEach((e=>{e.init&&e.init()})),this.#o=!0)}#u(){this.#l=this.config.map(this.#p.bind(this))}#p(t){const n="symbol"==typeof t.name?Symbol.keyFor(t.name):t.name,s=(0,e.Mb)(t.type);if("class"!==s&&"function"!==s&&"function class"!==s)throw new N(t.type);const r="class"===s||"function class"===s,a="class"===s?{args:(0,e._V)(t.type).args}:{args:(0,e.gg)(t.type).args},o={...a,args:a.args.map((n=>{const s=(0,e.un)(n);if(s&&s.value){const e=this.config.find((e=>e.type.name===s.value));if(!e)throw new I(t.name,s.name,s.value);return"symbol"==typeof e.name?Symbol.keyFor(e.name):e.name}return n}))};return new i(this.#a.createKey(this,n,t.lifecycle,r),n,t.type,r,t.lifecycle,o)}addDIObject(e){if(!(e instanceof DIObjectConfig))throw new C;const t=this.#p(e);return this.classTreeList.push(B.createDependencyTree(t,this.#l)),!0}#y(){this.classTreeList=this.#l.map((e=>B.createDependencyTree(e,this.#l)))}_createScopes(){}_initScopes(){}hasInstance(e){}getInstance(e,t){}_findClassTree(e,t){let n,s;switch(typeof e){case"string":n=t=>t.baseNode.name===e;break;case"symbol":n=t=>t.baseNode.name===Symbol.keyFor(e);break;default:n=t=>t.baseNode.type.name===e.name}if(s=void 0!==t?[...this.classTreeList].filter((e=>e.baseNode.lifecycle.id===t)).find(n):[...this.classTreeList].sort(((e,t)=>e.baseNode.lifecycle.id-t.baseNode.lifecycle.id)).find(n),s)return s}typeMatch(e,t){}getParent(){return this.#c}setParent(e){if(e instanceof q){if(e.getChildren().has(this.name))throw new Error("Parent already has this context as a child.");this.#c=e,e.addChild(this)}}_removeParent(){this.#c=null}_getChildInstance(e,t){let n;return[...this.#d.values()].find((s=>(n=s.getInstance(e,t),void 0!==n)))?n:void 0}getChildren(){return this.#d}addChild(e){if(!(e instanceof q))throw new R;this.#d.set(e.name,e)}deleteChild(e){this.#d.has(e)&&(this.#d.get(e)._removeParent(),this.#d.delete(e))}getScope(e){}filterClassesByLifecycle(e){return this.classTreeList.filter((t=>t.baseNode.lifecycle.id===e))}#m(e){}#f(){const e=new Set;this.#l.forEach((t=>t.constructor.args.forEach((n=>e.add({name:n,place:t.name}))))),e.forEach((e=>{if(void 0===this.#l.find((t=>t.name===e.name)))throw new v(e.place,e.name)}))}#g(t){if("class"!==(0,e.Mb)(t))return!0;const n=(0,e.qT)(t),s=-1!==this.config.findIndex((e=>e.type.name===n.name));if("Object"!==n.name){if(s){const s=(0,e._V)(t).args,r=(0,e._V)(n).args;if(s.length<r.length)throw new H(t.name,n.name)}return this.#g(n)}return!0}#h(){return this.#l.forEach((e=>{e.constructor.args.forEach((t=>{this.#b([e.name,t],t)}))})),!0}#b(e=[],t){if(0===this.#l.length)return;void 0===t&&(t=this.#l[0].name);const n=this.#l.find((e=>e.name===t));n.constructor.args.forEach((t=>{if(e.includes(t))throw new b(t,n.name);this.#b([...e,t],t)}))}}const V=q;class U extends Error{constructor(e,t){super(`${e}Container's classTreeList arg has class { ${t.name} } with another lifecycle.`),this.name="DI Container has class with invalid lifecycle type"}}const G=U;const W=class{constructor(e,t){this.func=e,this.args=t}call(){return this.func(...this.args)}};const J=class{static createInstance(e,t){return e.isClass?new e.type(...t):new W(e.type,t)}};class Q extends Error{constructor(){super("Invalid simple container parent. Parent must be an instance of AbstractContextContainer or it's derived class, null or undefined.")}}const X=class extends _{constructor(e,t=[]){if(!(e instanceof V))throw new Q;super(e,t)}_buildInstance(e){const t=[];e.baseNode.constructor.args.length>0&&e.baseNode.constructor.args.forEach((e=>{const n=this.getParent().classTreeList.find((t=>t.baseNode.name===e)),s=this.getInstance(n.baseNode.key)||this.getParent().getInstance(n.baseNode.name,n.baseNode.lifecycle.id,!0);if(s)return t.push(s);t.push(this._buildInstance(n))}));const n=J.createInstance(e.baseNode,t);return this.addInstance(e.baseNode.key,n),n}addInstance(){}},Y=function(e,t){if(e===t)return!0;if("object"==typeof e&&null!=e&&"object"==typeof t&&null!=t){if(Object.keys(e).length!==Object.keys(t).length)return!1;for(let n in e){if(!t.hasOwnProperty(n))return!1;if(!Y(e[n],t[n]))return!1}return!0}return!1},Z=Y;class ee extends Map{constructor(){super()}getBySymbol(e){let t;return this.forEach(((n,s)=>{Z(Symbol.keyFor(s),Symbol.keyFor(e))&&(t=n)})),t}hasBySymbol(e){let t=!1;return this.forEach(((n,s)=>{Z(Symbol.keyFor(s),Symbol.keyFor(e))&&(t=!0)})),t}}const te=ee;const ne=class extends X{constructor(e,t=[]){super(e,t);const n=t.find((e=>e.baseNode.lifecycle.id!==a.Session));if(n)throw new G("Session",n);this.#c=e}#w=!1;#c;#C=new te;init(){this.#w||(this.classTreeList.forEach((e=>{this.#C.has(e.baseNode.key.key)||this.#x(e)})),this.#w=!0)}#x(e){e.baseNode.lifecycle.beforeCreate();const t=this._buildInstance(e);return e.baseNode.lifecycle.afterCreate.bind(t)(),t}addInstance(e,t){if(!(e instanceof m))throw new Error("Invalid key type. Argument 'key' must be an instance of DIObjectKey class.");this.#C.set(e.key,t)}hasInstance(e){if(!this.#w)return!1;if(!(e instanceof m))throw new Error("Invalid argument 'key'. Argument 'key' must be an instance of DIObjectKey.");return this.#C.has(e.key)}getInstance(e){if(this.#w)return this.#C.get(e.key)}getParent(){return this.#c}};const se=class extends X{constructor(e,t=[]){super(e,t);const n=t.find((e=>e.baseNode.lifecycle.id!==a.Singletone));if(n)throw new G("Singletone",n);this.#c=e}#c;#C=new te;#x(e){e.baseNode.lifecycle.beforeCreate();const t=this._buildInstance(e);return e.baseNode.lifecycle.afterCreate.bind(t)(),t}addInstance(e,t){if(!(e instanceof m))throw new Error("Invalid key type. Argument 'key' must be an instance of DIObjectKey class.");this.#C.set(e.key,t)}hasInstance(e){return this.#C.has(e.key)}getInstance(e){const t=this.#C.get(e.key);if(t)return t;const n=this.classTreeList.find((t=>t.baseNode.key.key===e.key));return n?this.#x(n):void 0}getParent(){return this.#c}};class re extends Error{constructor(){super("Invalid demanded factory parent. Parent must be an instance of AbstractContextContainer or it's derived class, null or undefined.")}}class ie extends Error{constructor(){super("DemandedFactory constructor's argument 'classTreeList' is invalid. Argument 'classTreeList' must be an array of DependencyTree instances")}}const ae=class{constructor(e,t=[]){if(!(e instanceof V))throw new re;if(!Array.isArray(t)||t.length&&t.find((e=>!(e instanceof j))))throw new ie;const n=t.find((e=>e.baseNode.lifecycle.id!==a.Demanded));if(n)throw new G("Demanded",n);this.classTreeList=t,this.#c=e}#c;#x(e){const t=[];e.baseNode.constructor.args.length>0&&e.baseNode.constructor.args.forEach((e=>{const n=this.getParent().classTreeList.find((t=>t.baseNode.name===e)),s=n.baseNode.lifecycle.id!==a.Demanded?this.getParent().getInstance(n.baseNode.name,n.baseNode.lifecycle.id,!0):void 0;if(s)return t.push(s);t.push(this.createInstance(n.baseNode.key))})),e.baseNode.lifecycle.beforeCreate();const n=J.createInstance(e.baseNode,t);return e.baseNode.lifecycle.afterCreate.bind(n)(),n}createInstance(e){const t=this.classTreeList.find((t=>t.baseNode.key.key===e.key));if(t)return this.#x(t)}getParent(){return this.#c}};const oe=class extends V{constructor(e=[],t="",n=null,s=new M){super(e,t,n,s)}scopes=new Map;_createScopes(){new Set(this.classTreeList.map((e=>e.baseNode.lifecycle)).sort(((e,t)=>t.id-e.id))).forEach((e=>{switch(e.id){case a.Session:this.scopes.set(e.id,new ne(this,this.filterClassesByLifecycle(a.Session)));break;case a.Singletone:this.scopes.set(e.id,new se(this,this.filterClassesByLifecycle(a.Singletone)));break;case a.Demanded:this.scopes.set(e.id,new ae(this,this.filterClassesByLifecycle(a.Demanded)))}}))}_initScopes(){this.scopes.forEach((e=>{e.init&&e.init()}))}hasDIObject(e){return void 0!==this._findClassTree(e)}hasInstance(e){const t=this._findClassTree(e);if(void 0===t)return!1;const n=this.getScope(t.baseNode.lifecycle.id);return t.baseNode.lifecycle.id!==a.Demanded&&n.hasInstance(t.baseNode.key)}getInstance(e,t,n){const s=this._findClassTree(e,t);if(void 0===s){if(n)return;return this._getChildInstance(e,t)}const r=s.baseNode.key,i=this.getScope(s.baseNode.lifecycle.id);if(!i){if(n)return;return this._getChildInstance(e,t)}return i instanceof ae?i.createInstance(r):n?i.getInstance(r):i.getInstance(r)??this._getChildInstance(e,t)}typeMatch(e,t){const n=this._findClassTree(e);if(void 0===n)throw new Error("There is no di object with this name.");return n.baseNode.type===t}getScope(e){return"number"==typeof e&&Object.values(a).find((t=>t===e))?this.scopes.get(e):null}};class ce extends Error{constructor(){super("Invalid context parent. Parent must be an instance of AbstractContextContainer or it's derived class, null or undefined.")}}const le=ce;class de extends Error{constructor(){super("Invalid context keyFactory. KeyFactory must be an instance of DIObjectKeyFactory or it's derived class")}}const ue=de;class fe{createContainer(e=[],t="",n=null,s=new M){if(fe.validateContainerParams(e,t,n,s)){const r=new V(e,t,n,s);return r.setParent(n),r}}static validateContainerParams(e,t,n,s){if(!Array.isArray(e)||e.find((e=>!(e instanceof y))))throw new C;if(null!=n&&!(n instanceof V))throw new le;if(!t)throw new Error("Name of Context must be a non empty string.");if(!(s instanceof M))throw new ue;return!0}}const he=fe,ye=e=>{let t="";for(let n=0;n<e;n++)t+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(Math.random()*e));return t};class pe extends Error{constructor(){super("Invalid context name type. Type of context name must be a string.")}}const me=pe;class ge extends Error{constructor(e){super(`Context name '${e}' is not unique. Context name must be unique string.`)}}const be=ge;class we extends he{static#I=new Set;static#D(e){if("string"!=typeof e)throw new me;if(we.#I.has(e))throw new be(e);we.#I.add(e)}static createContainer(e=[],t="",n=null,s=new M){if(""===t&&(t=ye(7)),super.validateContainerParams(e,t,n,s)){const r=new oe(e,t,n,s);return r.setParent(n),we.#D(t),r}return null}}const Ce=we,xe={ContextContainer:oe,AbstractContextContainer:V,DemandedFactory:ae,SimpleContainer:X,SessionContainer:ne,SingletoneContainer:se,DIObjectKey:m,DemandedConfig:class extends y{constructor(e="",t={},n=(()=>{}),s=(()=>{})){super(e,t,new o(n,s))}},SessionConfig:class extends y{constructor(e="",t={},n=(()=>{}),s=(()=>{})){super(e,t,new c(n,s))}},SingletoneConfig:class extends y{constructor(e="",t={},n=(()=>{}),s=(()=>{})){super(e,t,new l(n,s))}},DIObjectConfig:y,DIClazz:i,DemandedLifecycle:o,SingletoneLifecycle:l,SessionLifecycle:c,Lifecycle:r,ContextContainerFactory:Ce,AbstractContextContainerFactory:he};module.exports.ContextContainer=xe.ContextContainer,module.exports.AbstractContextContainer=xe.AbstractContextContainer,module.exports.ContextContainerFactory=xe.ContextContainerFactory,module.exports.AbstractContextContainerFactory=xe.AbstractContextContainerFactory,module.exports.DemandedConfig=xe.DemandedConfig,module.exports.SessionConfig=xe.SessionConfig,module.exports.SingletoneConfig=xe.SingletoneConfig,module.exports.DIObjectConfig=xe.DIObjectConfig,module.exports.DIClazz=xe.DIClazz,module.exports.DIObjectKey=xe.DIObjectKey,module.exports.SingletoneContainer=xe.SingletoneContainer,module.exports.SimpleContainer=xe.SimpleContainer,module.exports.DemandedFactory=xe.DemandedFactory,module.exports.SessionContainer=xe.SessionContainer,module.exports.DemandedLifecycle=xe.DemandedLifecycle,module.exports.SingletoneLifecycle=xe.SingletoneLifecycle,module.exports.SessionLifecycle=xe.SessionLifecycle,module.exports.Lifecycle=xe.Lifecycle,module.exports=xe})(),s})()));
//# sourceMappingURL=dizy.js.map